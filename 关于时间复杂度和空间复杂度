时间复杂度 
计算时间复杂度的方法：

用常数1代替运行时间中的所有加法常数
修改后的运行次数函数中，只保留最高阶项
去除最高阶项的系数
按数量级递增排列，常见的时间复杂度有： 
常数阶O(1),对数阶O(log2n),线性阶O(n), 
线性对数阶O(nlog2n),平方阶O(n^2)，立方阶O(n^3),…， 
k次方阶O(n^k),指数阶O(2^n)。 
随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低。

举个栗子:

sum = n*(n+1)/2;        //时间复杂度O(1)
1
for(int i = 0; i < n; i++){
    printf("%d ",i);
}                       
//时间复杂度O(n)
1
2
3
4
for(int i = 0; i < n; i++){
    for(int j = 0; j < n; j++){
        printf("%d ",i);
    }
}               
//时间复杂度O(n^2)
1
2
3
4
5
6
for(int i = 0; i < n; i++){
    for(int j = i; j < n; j++){
        printf("%d ",i);
    }
}   
//运行次数为(1+n)*n/2
//时间复杂度O(n^2)
1
2
3
4
5
6
7
int i = 1, n = 100;
while(i < n){
    i = i * 2;
}
//设执行次数为x. 2^x = n 即x = log2n
//时间复杂度O(log2n)



空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度，记做S(n)=O(f(n))。比如直接插入排序的时间复杂度是O(n^2),空间复杂
度是O(1) 。而一般的递归算法就要有O(n)的空间复杂度了，因为每次递归都要存储返回信息。一个算法的优劣主要从算法的执行时间和所需要占用的存储空间两个方面
衡量。不会百度把
