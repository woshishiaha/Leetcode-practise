Given a 32-bit signed integer, reverse digits of an integer.

Example 1:

Input: 123
Output:  321
Example 2:

Input: -123
Output: -321
Example 3:

Input: 120
Output: 21
Note:
Assume we are dealing with an environment which could only hold integers within the 32-bit signed integer range. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.

My code:
class Solution {
public:
    int reverse(int x) {
      int ans = 0;
        while(x)
        {
            int temp = ans * 10 + x%10;
            if(temp/10 != ans)
                return 0;
            ans = temp;
            x = x/10;
        }
        return ans;
    }
};

//先注意一下，题目最后要判断int x 是不是32位带符号的整数，如今我看到了二种方法。
//第一种：就是我代码当中的，if(temp/10 != ans)     return 0;   为什么可以呢，因为如果x是超出32位带符号的整数范围的话呢，算出来的temp是一堆究极混论数字
//所以除以10是不可能再等于回ans的。（至于为什么是这样。。我也不知道，要查一查。）

//第二种：是现在程序里面if ( sign == 1 &&  ans > INT_MAX) return 0;       if ( sign == -1 && ans < INT_MIN) return 0;


//除了判断整数之外，这道题还有就是关于怎么分解每一位数字并且重新组装它，总结来就是：对n取余是得到n的个位数，n/10就是把n的个位数去掉。
                
