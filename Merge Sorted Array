Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.

Note:
You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of 
elements initialized in nums1 and nums2 are m and n respectively.


//这道题对于大神来说很JB简单。。但是对我这种究极无敌纯新人来说简直蓝瘦。。想了2个小事愣是没搞出来。。应该是想法不对，越走越远。。帖代码：

class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
       for(int i = nums1.size()-1; i >= 0 ; i--)
       {
           int j = nums1.size();
          
               if(j == m)
               break;
           
               if(nums1[i] == 0)
               {
                   nums1.erase(nums1.begin()+i);
               }
       
           
       }
        
        if(nums1.empty() || m == 0)
        {
            nums1.clear();
            for(int a = n-1; a >=0; a--)
            {
                nums1.push_back(nums2[a]);
            }
        }
        else
        {
        int i = m-1, j = n-1;
        for(j; j >=0 ; --j)
        {
            if(nums2[j] < nums1[0])
            {
                nums1.insert(nums1.begin(), nums2[j]);
                break;
            }
            for(i ; i >=0 ; --i)
            {
                if(nums2[j] > nums1[i])
                {
                    nums1.insert(nums1.begin()+i, nums2[j]);
                    break;
                }   
            }
        }
        while(j > 0)
        {
            nums1.insert(nums1.begin(), nums2[j]);
            j--;
        }
     }
    }
};

//这段代码并没有通过。首先我没有考虑到vector当中有冗余数据的情况（即里面有0但实际并不需要0）。遇到vector习惯性的先想insert，其实有时候是不对的，比如
//这道题。
//题目其实简单的一批，根本不用那么麻烦，题目都说了，假设nums1最后是>=m+n，所以直接从最大的开始比起，然后插入到nums1[n+m-1]当中去，就可以了。leetcode
//上面的示范：
void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
   for(int i=m-1, j=n-1, k=m+n-1; j>=0; )
       nums1[k--] = i>=0 && nums1[i]>nums2[j]? nums1[i--]: nums2[j--];
}
